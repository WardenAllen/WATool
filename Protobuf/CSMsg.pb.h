// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSMsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_CSMsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_CSMsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "CSBase.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_CSMsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_CSMsg_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_CSMsg_2eproto;
namespace CSProto {
class EnterRoomAck;
class EnterRoomAckDefaultTypeInternal;
extern EnterRoomAckDefaultTypeInternal _EnterRoomAck_default_instance_;
class EnterRoomNtf;
class EnterRoomNtfDefaultTypeInternal;
extern EnterRoomNtfDefaultTypeInternal _EnterRoomNtf_default_instance_;
class EnterRoomReq;
class EnterRoomReqDefaultTypeInternal;
extern EnterRoomReqDefaultTypeInternal _EnterRoomReq_default_instance_;
class ErrorAck;
class ErrorAckDefaultTypeInternal;
extern ErrorAckDefaultTypeInternal _ErrorAck_default_instance_;
class LoginAck;
class LoginAckDefaultTypeInternal;
extern LoginAckDefaultTypeInternal _LoginAck_default_instance_;
class LoginReq;
class LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class MoveAck;
class MoveAckDefaultTypeInternal;
extern MoveAckDefaultTypeInternal _MoveAck_default_instance_;
class MoveNtf;
class MoveNtfDefaultTypeInternal;
extern MoveNtfDefaultTypeInternal _MoveNtf_default_instance_;
class MoveReq;
class MoveReqDefaultTypeInternal;
extern MoveReqDefaultTypeInternal _MoveReq_default_instance_;
class SYS_PING;
class SYS_PINGDefaultTypeInternal;
extern SYS_PINGDefaultTypeInternal _SYS_PING_default_instance_;
class SYS_PONG;
class SYS_PONGDefaultTypeInternal;
extern SYS_PONGDefaultTypeInternal _SYS_PONG_default_instance_;
class TestAck;
class TestAckDefaultTypeInternal;
extern TestAckDefaultTypeInternal _TestAck_default_instance_;
class TestAck_TestMapEntry_DoNotUse;
class TestAck_TestMapEntry_DoNotUseDefaultTypeInternal;
extern TestAck_TestMapEntry_DoNotUseDefaultTypeInternal _TestAck_TestMapEntry_DoNotUse_default_instance_;
class TestReq;
class TestReqDefaultTypeInternal;
extern TestReqDefaultTypeInternal _TestReq_default_instance_;
}  // namespace CSProto
PROTOBUF_NAMESPACE_OPEN
template<> ::CSProto::EnterRoomAck* Arena::CreateMaybeMessage<::CSProto::EnterRoomAck>(Arena*);
template<> ::CSProto::EnterRoomNtf* Arena::CreateMaybeMessage<::CSProto::EnterRoomNtf>(Arena*);
template<> ::CSProto::EnterRoomReq* Arena::CreateMaybeMessage<::CSProto::EnterRoomReq>(Arena*);
template<> ::CSProto::ErrorAck* Arena::CreateMaybeMessage<::CSProto::ErrorAck>(Arena*);
template<> ::CSProto::LoginAck* Arena::CreateMaybeMessage<::CSProto::LoginAck>(Arena*);
template<> ::CSProto::LoginReq* Arena::CreateMaybeMessage<::CSProto::LoginReq>(Arena*);
template<> ::CSProto::MoveAck* Arena::CreateMaybeMessage<::CSProto::MoveAck>(Arena*);
template<> ::CSProto::MoveNtf* Arena::CreateMaybeMessage<::CSProto::MoveNtf>(Arena*);
template<> ::CSProto::MoveReq* Arena::CreateMaybeMessage<::CSProto::MoveReq>(Arena*);
template<> ::CSProto::SYS_PING* Arena::CreateMaybeMessage<::CSProto::SYS_PING>(Arena*);
template<> ::CSProto::SYS_PONG* Arena::CreateMaybeMessage<::CSProto::SYS_PONG>(Arena*);
template<> ::CSProto::TestAck* Arena::CreateMaybeMessage<::CSProto::TestAck>(Arena*);
template<> ::CSProto::TestAck_TestMapEntry_DoNotUse* Arena::CreateMaybeMessage<::CSProto::TestAck_TestMapEntry_DoNotUse>(Arena*);
template<> ::CSProto::TestReq* Arena::CreateMaybeMessage<::CSProto::TestReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CSProto {

// ===================================================================

class SYS_PING PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.SYS_PING) */ {
 public:
  inline SYS_PING() : SYS_PING(nullptr) {}
  virtual ~SYS_PING();

  SYS_PING(const SYS_PING& from);
  SYS_PING(SYS_PING&& from) noexcept
    : SYS_PING() {
    *this = ::std::move(from);
  }

  inline SYS_PING& operator=(const SYS_PING& from) {
    CopyFrom(from);
    return *this;
  }
  inline SYS_PING& operator=(SYS_PING&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SYS_PING& default_instance();

  static inline const SYS_PING* internal_default_instance() {
    return reinterpret_cast<const SYS_PING*>(
               &_SYS_PING_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SYS_PING& a, SYS_PING& b) {
    a.Swap(&b);
  }
  inline void Swap(SYS_PING* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SYS_PING* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SYS_PING* New() const final {
    return CreateMaybeMessage<SYS_PING>(nullptr);
  }

  SYS_PING* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SYS_PING>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SYS_PING& from);
  void MergeFrom(const SYS_PING& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SYS_PING* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.SYS_PING";
  }
  protected:
  explicit SYS_PING(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTsFieldNumber = 1,
  };
  // int64 ts = 1;
  void clear_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 ts() const;
  void set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ts() const;
  void _internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:CSProto.SYS_PING)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 ts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class SYS_PONG PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.SYS_PONG) */ {
 public:
  inline SYS_PONG() : SYS_PONG(nullptr) {}
  virtual ~SYS_PONG();

  SYS_PONG(const SYS_PONG& from);
  SYS_PONG(SYS_PONG&& from) noexcept
    : SYS_PONG() {
    *this = ::std::move(from);
  }

  inline SYS_PONG& operator=(const SYS_PONG& from) {
    CopyFrom(from);
    return *this;
  }
  inline SYS_PONG& operator=(SYS_PONG&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SYS_PONG& default_instance();

  static inline const SYS_PONG* internal_default_instance() {
    return reinterpret_cast<const SYS_PONG*>(
               &_SYS_PONG_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SYS_PONG& a, SYS_PONG& b) {
    a.Swap(&b);
  }
  inline void Swap(SYS_PONG* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SYS_PONG* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SYS_PONG* New() const final {
    return CreateMaybeMessage<SYS_PONG>(nullptr);
  }

  SYS_PONG* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SYS_PONG>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SYS_PONG& from);
  void MergeFrom(const SYS_PONG& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SYS_PONG* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.SYS_PONG";
  }
  protected:
  explicit SYS_PONG(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTsFieldNumber = 1,
  };
  // int64 ts = 1;
  void clear_ts();
  ::PROTOBUF_NAMESPACE_ID::int64 ts() const;
  void set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ts() const;
  void _internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:CSProto.SYS_PONG)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 ts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class TestReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.TestReq) */ {
 public:
  inline TestReq() : TestReq(nullptr) {}
  virtual ~TestReq();

  TestReq(const TestReq& from);
  TestReq(TestReq&& from) noexcept
    : TestReq() {
    *this = ::std::move(from);
  }

  inline TestReq& operator=(const TestReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestReq& operator=(TestReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestReq& default_instance();

  static inline const TestReq* internal_default_instance() {
    return reinterpret_cast<const TestReq*>(
               &_TestReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TestReq& a, TestReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TestReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestReq* New() const final {
    return CreateMaybeMessage<TestReq>(nullptr);
  }

  TestReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestReq& from);
  void MergeFrom(const TestReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.TestReq";
  }
  protected:
  explicit TestReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // string Data = 1;
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:CSProto.TestReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class TestAck_TestMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestAck_TestMapEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<TestAck_TestMapEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  TestAck_TestMapEntry_DoNotUse();
  explicit TestAck_TestMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TestAck_TestMapEntry_DoNotUse& other);
  static const TestAck_TestMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TestAck_TestMapEntry_DoNotUse*>(&_TestAck_TestMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class TestAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.TestAck) */ {
 public:
  inline TestAck() : TestAck(nullptr) {}
  virtual ~TestAck();

  TestAck(const TestAck& from);
  TestAck(TestAck&& from) noexcept
    : TestAck() {
    *this = ::std::move(from);
  }

  inline TestAck& operator=(const TestAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestAck& operator=(TestAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestAck& default_instance();

  static inline const TestAck* internal_default_instance() {
    return reinterpret_cast<const TestAck*>(
               &_TestAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TestAck& a, TestAck& b) {
    a.Swap(&b);
  }
  inline void Swap(TestAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestAck* New() const final {
    return CreateMaybeMessage<TestAck>(nullptr);
  }

  TestAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestAck& from);
  void MergeFrom(const TestAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.TestAck";
  }
  protected:
  explicit TestAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTestMapFieldNumber = 3,
    kTestDataFieldNumber = 2,
    kErrFieldNumber = 1,
  };
  // map<uint32, int32> TestMap = 3;
  int testmap_size() const;
  private:
  int _internal_testmap_size() const;
  public:
  void clear_testmap();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_testmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_testmap();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32 >&
      testmap() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_testmap();

  // string TestData = 2;
  void clear_testdata();
  const std::string& testdata() const;
  void set_testdata(const std::string& value);
  void set_testdata(std::string&& value);
  void set_testdata(const char* value);
  void set_testdata(const char* value, size_t size);
  std::string* mutable_testdata();
  std::string* release_testdata();
  void set_allocated_testdata(std::string* testdata);
  private:
  const std::string& _internal_testdata() const;
  void _internal_set_testdata(const std::string& value);
  std::string* _internal_mutable_testdata();
  public:

  // .CSProto.ErrorCodeID Err = 1;
  void clear_err();
  ::CSProto::ErrorCodeID err() const;
  void set_err(::CSProto::ErrorCodeID value);
  private:
  ::CSProto::ErrorCodeID _internal_err() const;
  void _internal_set_err(::CSProto::ErrorCodeID value);
  public:

  // @@protoc_insertion_point(class_scope:CSProto.TestAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      TestAck_TestMapEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> testmap_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr testdata_;
  int err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class ErrorAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.ErrorAck) */ {
 public:
  inline ErrorAck() : ErrorAck(nullptr) {}
  virtual ~ErrorAck();

  ErrorAck(const ErrorAck& from);
  ErrorAck(ErrorAck&& from) noexcept
    : ErrorAck() {
    *this = ::std::move(from);
  }

  inline ErrorAck& operator=(const ErrorAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorAck& operator=(ErrorAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ErrorAck& default_instance();

  static inline const ErrorAck* internal_default_instance() {
    return reinterpret_cast<const ErrorAck*>(
               &_ErrorAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ErrorAck& a, ErrorAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ErrorAck* New() const final {
    return CreateMaybeMessage<ErrorAck>(nullptr);
  }

  ErrorAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ErrorAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ErrorAck& from);
  void MergeFrom(const ErrorAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.ErrorAck";
  }
  protected:
  explicit ErrorAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIDFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .CSProto.MsgID ID = 1;
  void clear_id();
  ::CSProto::MsgID id() const;
  void set_id(::CSProto::MsgID value);
  private:
  ::CSProto::MsgID _internal_id() const;
  void _internal_set_id(::CSProto::MsgID value);
  public:

  // .CSProto.ErrorCodeID Error = 2;
  void clear_error();
  ::CSProto::ErrorCodeID error() const;
  void set_error(::CSProto::ErrorCodeID value);
  private:
  ::CSProto::ErrorCodeID _internal_error() const;
  void _internal_set_error(::CSProto::ErrorCodeID value);
  public:

  // @@protoc_insertion_point(class_scope:CSProto.ErrorAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int id_;
  int error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class LoginReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.LoginReq) */ {
 public:
  inline LoginReq() : LoginReq(nullptr) {}
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginReq& default_instance();

  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginReq* New() const final {
    return CreateMaybeMessage<LoginReq>(nullptr);
  }

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.LoginReq";
  }
  protected:
  explicit LoginReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // string Username = 2;
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // uint64 UserId = 1;
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::uint64 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:CSProto.LoginReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::uint64 userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class LoginAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.LoginAck) */ {
 public:
  inline LoginAck() : LoginAck(nullptr) {}
  virtual ~LoginAck();

  LoginAck(const LoginAck& from);
  LoginAck(LoginAck&& from) noexcept
    : LoginAck() {
    *this = ::std::move(from);
  }

  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAck& operator=(LoginAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginAck& default_instance();

  static inline const LoginAck* internal_default_instance() {
    return reinterpret_cast<const LoginAck*>(
               &_LoginAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LoginAck& a, LoginAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginAck* New() const final {
    return CreateMaybeMessage<LoginAck>(nullptr);
  }

  LoginAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginAck& from);
  void MergeFrom(const LoginAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.LoginAck";
  }
  protected:
  explicit LoginAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
  };
  // .CSProto.ErrorCodeID Err = 1;
  void clear_err();
  ::CSProto::ErrorCodeID err() const;
  void set_err(::CSProto::ErrorCodeID value);
  private:
  ::CSProto::ErrorCodeID _internal_err() const;
  void _internal_set_err(::CSProto::ErrorCodeID value);
  public:

  // @@protoc_insertion_point(class_scope:CSProto.LoginAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.EnterRoomReq) */ {
 public:
  inline EnterRoomReq() : EnterRoomReq(nullptr) {}
  virtual ~EnterRoomReq();

  EnterRoomReq(const EnterRoomReq& from);
  EnterRoomReq(EnterRoomReq&& from) noexcept
    : EnterRoomReq() {
    *this = ::std::move(from);
  }

  inline EnterRoomReq& operator=(const EnterRoomReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomReq& operator=(EnterRoomReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnterRoomReq& default_instance();

  static inline const EnterRoomReq* internal_default_instance() {
    return reinterpret_cast<const EnterRoomReq*>(
               &_EnterRoomReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EnterRoomReq& a, EnterRoomReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnterRoomReq* New() const final {
    return CreateMaybeMessage<EnterRoomReq>(nullptr);
  }

  EnterRoomReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnterRoomReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnterRoomReq& from);
  void MergeFrom(const EnterRoomReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.EnterRoomReq";
  }
  protected:
  explicit EnterRoomReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSProto.EnterRoomReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.EnterRoomAck) */ {
 public:
  inline EnterRoomAck() : EnterRoomAck(nullptr) {}
  virtual ~EnterRoomAck();

  EnterRoomAck(const EnterRoomAck& from);
  EnterRoomAck(EnterRoomAck&& from) noexcept
    : EnterRoomAck() {
    *this = ::std::move(from);
  }

  inline EnterRoomAck& operator=(const EnterRoomAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomAck& operator=(EnterRoomAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnterRoomAck& default_instance();

  static inline const EnterRoomAck* internal_default_instance() {
    return reinterpret_cast<const EnterRoomAck*>(
               &_EnterRoomAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EnterRoomAck& a, EnterRoomAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnterRoomAck* New() const final {
    return CreateMaybeMessage<EnterRoomAck>(nullptr);
  }

  EnterRoomAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnterRoomAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnterRoomAck& from);
  void MergeFrom(const EnterRoomAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.EnterRoomAck";
  }
  protected:
  explicit EnterRoomAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrFieldNumber = 1,
  };
  // .CSProto.ErrorCodeID Err = 1;
  void clear_err();
  ::CSProto::ErrorCodeID err() const;
  void set_err(::CSProto::ErrorCodeID value);
  private:
  ::CSProto::ErrorCodeID _internal_err() const;
  void _internal_set_err(::CSProto::ErrorCodeID value);
  public:

  // @@protoc_insertion_point(class_scope:CSProto.EnterRoomAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int err_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class EnterRoomNtf PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.EnterRoomNtf) */ {
 public:
  inline EnterRoomNtf() : EnterRoomNtf(nullptr) {}
  virtual ~EnterRoomNtf();

  EnterRoomNtf(const EnterRoomNtf& from);
  EnterRoomNtf(EnterRoomNtf&& from) noexcept
    : EnterRoomNtf() {
    *this = ::std::move(from);
  }

  inline EnterRoomNtf& operator=(const EnterRoomNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterRoomNtf& operator=(EnterRoomNtf&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnterRoomNtf& default_instance();

  static inline const EnterRoomNtf* internal_default_instance() {
    return reinterpret_cast<const EnterRoomNtf*>(
               &_EnterRoomNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EnterRoomNtf& a, EnterRoomNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterRoomNtf* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnterRoomNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnterRoomNtf* New() const final {
    return CreateMaybeMessage<EnterRoomNtf>(nullptr);
  }

  EnterRoomNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnterRoomNtf>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnterRoomNtf& from);
  void MergeFrom(const EnterRoomNtf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnterRoomNtf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.EnterRoomNtf";
  }
  protected:
  explicit EnterRoomNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleListFieldNumber = 1,
  };
  // repeated .CSProto.EnterRoomRoleInfo RoleList = 1;
  int rolelist_size() const;
  private:
  int _internal_rolelist_size() const;
  public:
  void clear_rolelist();
  ::CSProto::EnterRoomRoleInfo* mutable_rolelist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSProto::EnterRoomRoleInfo >*
      mutable_rolelist();
  private:
  const ::CSProto::EnterRoomRoleInfo& _internal_rolelist(int index) const;
  ::CSProto::EnterRoomRoleInfo* _internal_add_rolelist();
  public:
  const ::CSProto::EnterRoomRoleInfo& rolelist(int index) const;
  ::CSProto::EnterRoomRoleInfo* add_rolelist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSProto::EnterRoomRoleInfo >&
      rolelist() const;

  // @@protoc_insertion_point(class_scope:CSProto.EnterRoomNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSProto::EnterRoomRoleInfo > rolelist_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class MoveReq PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.MoveReq) */ {
 public:
  inline MoveReq() : MoveReq(nullptr) {}
  virtual ~MoveReq();

  MoveReq(const MoveReq& from);
  MoveReq(MoveReq&& from) noexcept
    : MoveReq() {
    *this = ::std::move(from);
  }

  inline MoveReq& operator=(const MoveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveReq& operator=(MoveReq&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveReq& default_instance();

  static inline const MoveReq* internal_default_instance() {
    return reinterpret_cast<const MoveReq*>(
               &_MoveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MoveReq& a, MoveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveReq* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveReq* New() const final {
    return CreateMaybeMessage<MoveReq>(nullptr);
  }

  MoveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveReq& from);
  void MergeFrom(const MoveReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.MoveReq";
  }
  protected:
  explicit MoveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMovementFieldNumber = 1,
  };
  // .CSProto.MovementInfo Movement = 1;
  bool has_movement() const;
  private:
  bool _internal_has_movement() const;
  public:
  void clear_movement();
  const ::CSProto::MovementInfo& movement() const;
  ::CSProto::MovementInfo* release_movement();
  ::CSProto::MovementInfo* mutable_movement();
  void set_allocated_movement(::CSProto::MovementInfo* movement);
  private:
  const ::CSProto::MovementInfo& _internal_movement() const;
  ::CSProto::MovementInfo* _internal_mutable_movement();
  public:
  void unsafe_arena_set_allocated_movement(
      ::CSProto::MovementInfo* movement);
  ::CSProto::MovementInfo* unsafe_arena_release_movement();

  // @@protoc_insertion_point(class_scope:CSProto.MoveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CSProto::MovementInfo* movement_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class MoveAck PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.MoveAck) */ {
 public:
  inline MoveAck() : MoveAck(nullptr) {}
  virtual ~MoveAck();

  MoveAck(const MoveAck& from);
  MoveAck(MoveAck&& from) noexcept
    : MoveAck() {
    *this = ::std::move(from);
  }

  inline MoveAck& operator=(const MoveAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveAck& operator=(MoveAck&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveAck& default_instance();

  static inline const MoveAck* internal_default_instance() {
    return reinterpret_cast<const MoveAck*>(
               &_MoveAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MoveAck& a, MoveAck& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveAck* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveAck* New() const final {
    return CreateMaybeMessage<MoveAck>(nullptr);
  }

  MoveAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveAck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveAck& from);
  void MergeFrom(const MoveAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.MoveAck";
  }
  protected:
  explicit MoveAck(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMovementFieldNumber = 1,
  };
  // .CSProto.MovementInfo Movement = 1;
  bool has_movement() const;
  private:
  bool _internal_has_movement() const;
  public:
  void clear_movement();
  const ::CSProto::MovementInfo& movement() const;
  ::CSProto::MovementInfo* release_movement();
  ::CSProto::MovementInfo* mutable_movement();
  void set_allocated_movement(::CSProto::MovementInfo* movement);
  private:
  const ::CSProto::MovementInfo& _internal_movement() const;
  ::CSProto::MovementInfo* _internal_mutable_movement();
  public:
  void unsafe_arena_set_allocated_movement(
      ::CSProto::MovementInfo* movement);
  ::CSProto::MovementInfo* unsafe_arena_release_movement();

  // @@protoc_insertion_point(class_scope:CSProto.MoveAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CSProto::MovementInfo* movement_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// -------------------------------------------------------------------

class MoveNtf PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSProto.MoveNtf) */ {
 public:
  inline MoveNtf() : MoveNtf(nullptr) {}
  virtual ~MoveNtf();

  MoveNtf(const MoveNtf& from);
  MoveNtf(MoveNtf&& from) noexcept
    : MoveNtf() {
    *this = ::std::move(from);
  }

  inline MoveNtf& operator=(const MoveNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveNtf& operator=(MoveNtf&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MoveNtf& default_instance();

  static inline const MoveNtf* internal_default_instance() {
    return reinterpret_cast<const MoveNtf*>(
               &_MoveNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MoveNtf& a, MoveNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveNtf* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveNtf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MoveNtf* New() const final {
    return CreateMaybeMessage<MoveNtf>(nullptr);
  }

  MoveNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MoveNtf>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MoveNtf& from);
  void MergeFrom(const MoveNtf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveNtf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSProto.MoveNtf";
  }
  protected:
  explicit MoveNtf(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_CSMsg_2eproto);
    return ::descriptor_table_CSMsg_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMoveRoleFieldNumber = 1,
  };
  // .CSProto.MoveRoleInfo MoveRole = 1;
  bool has_moverole() const;
  private:
  bool _internal_has_moverole() const;
  public:
  void clear_moverole();
  const ::CSProto::MoveRoleInfo& moverole() const;
  ::CSProto::MoveRoleInfo* release_moverole();
  ::CSProto::MoveRoleInfo* mutable_moverole();
  void set_allocated_moverole(::CSProto::MoveRoleInfo* moverole);
  private:
  const ::CSProto::MoveRoleInfo& _internal_moverole() const;
  ::CSProto::MoveRoleInfo* _internal_mutable_moverole();
  public:
  void unsafe_arena_set_allocated_moverole(
      ::CSProto::MoveRoleInfo* moverole);
  ::CSProto::MoveRoleInfo* unsafe_arena_release_moverole();

  // @@protoc_insertion_point(class_scope:CSProto.MoveNtf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::CSProto::MoveRoleInfo* moverole_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_CSMsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SYS_PING

// int64 ts = 1;
inline void SYS_PING::clear_ts() {
  ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SYS_PING::_internal_ts() const {
  return ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SYS_PING::ts() const {
  // @@protoc_insertion_point(field_get:CSProto.SYS_PING.ts)
  return _internal_ts();
}
inline void SYS_PING::_internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  ts_ = value;
}
inline void SYS_PING::set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:CSProto.SYS_PING.ts)
}

// -------------------------------------------------------------------

// SYS_PONG

// int64 ts = 1;
inline void SYS_PONG::clear_ts() {
  ts_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SYS_PONG::_internal_ts() const {
  return ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SYS_PONG::ts() const {
  // @@protoc_insertion_point(field_get:CSProto.SYS_PONG.ts)
  return _internal_ts();
}
inline void SYS_PONG::_internal_set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  ts_ = value;
}
inline void SYS_PONG::set_ts(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:CSProto.SYS_PONG.ts)
}

// -------------------------------------------------------------------

// TestReq

// string Data = 1;
inline void TestReq::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& TestReq::data() const {
  // @@protoc_insertion_point(field_get:CSProto.TestReq.Data)
  return _internal_data();
}
inline void TestReq::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:CSProto.TestReq.Data)
}
inline std::string* TestReq::mutable_data() {
  // @@protoc_insertion_point(field_mutable:CSProto.TestReq.Data)
  return _internal_mutable_data();
}
inline const std::string& TestReq::_internal_data() const {
  return data_.Get();
}
inline void TestReq::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TestReq::set_data(std::string&& value) {
  
  data_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:CSProto.TestReq.Data)
}
inline void TestReq::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:CSProto.TestReq.Data)
}
inline void TestReq::set_data(const char* value,
    size_t size) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:CSProto.TestReq.Data)
}
inline std::string* TestReq::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TestReq::release_data() {
  // @@protoc_insertion_point(field_release:CSProto.TestReq.Data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TestReq::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:CSProto.TestReq.Data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TestAck

// .CSProto.ErrorCodeID Err = 1;
inline void TestAck::clear_err() {
  err_ = 0;
}
inline ::CSProto::ErrorCodeID TestAck::_internal_err() const {
  return static_cast< ::CSProto::ErrorCodeID >(err_);
}
inline ::CSProto::ErrorCodeID TestAck::err() const {
  // @@protoc_insertion_point(field_get:CSProto.TestAck.Err)
  return _internal_err();
}
inline void TestAck::_internal_set_err(::CSProto::ErrorCodeID value) {
  
  err_ = value;
}
inline void TestAck::set_err(::CSProto::ErrorCodeID value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:CSProto.TestAck.Err)
}

// string TestData = 2;
inline void TestAck::clear_testdata() {
  testdata_.ClearToEmpty();
}
inline const std::string& TestAck::testdata() const {
  // @@protoc_insertion_point(field_get:CSProto.TestAck.TestData)
  return _internal_testdata();
}
inline void TestAck::set_testdata(const std::string& value) {
  _internal_set_testdata(value);
  // @@protoc_insertion_point(field_set:CSProto.TestAck.TestData)
}
inline std::string* TestAck::mutable_testdata() {
  // @@protoc_insertion_point(field_mutable:CSProto.TestAck.TestData)
  return _internal_mutable_testdata();
}
inline const std::string& TestAck::_internal_testdata() const {
  return testdata_.Get();
}
inline void TestAck::_internal_set_testdata(const std::string& value) {
  
  testdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TestAck::set_testdata(std::string&& value) {
  
  testdata_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:CSProto.TestAck.TestData)
}
inline void TestAck::set_testdata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  testdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:CSProto.TestAck.TestData)
}
inline void TestAck::set_testdata(const char* value,
    size_t size) {
  
  testdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:CSProto.TestAck.TestData)
}
inline std::string* TestAck::_internal_mutable_testdata() {
  
  return testdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TestAck::release_testdata() {
  // @@protoc_insertion_point(field_release:CSProto.TestAck.TestData)
  return testdata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TestAck::set_allocated_testdata(std::string* testdata) {
  if (testdata != nullptr) {
    
  } else {
    
  }
  testdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), testdata,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:CSProto.TestAck.TestData)
}

// map<uint32, int32> TestMap = 3;
inline int TestAck::_internal_testmap_size() const {
  return testmap_.size();
}
inline int TestAck::testmap_size() const {
  return _internal_testmap_size();
}
inline void TestAck::clear_testmap() {
  testmap_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32 >&
TestAck::_internal_testmap() const {
  return testmap_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32 >&
TestAck::testmap() const {
  // @@protoc_insertion_point(field_map:CSProto.TestAck.TestMap)
  return _internal_testmap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32 >*
TestAck::_internal_mutable_testmap() {
  return testmap_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::int32 >*
TestAck::mutable_testmap() {
  // @@protoc_insertion_point(field_mutable_map:CSProto.TestAck.TestMap)
  return _internal_mutable_testmap();
}

// -------------------------------------------------------------------

// ErrorAck

// .CSProto.MsgID ID = 1;
inline void ErrorAck::clear_id() {
  id_ = 0;
}
inline ::CSProto::MsgID ErrorAck::_internal_id() const {
  return static_cast< ::CSProto::MsgID >(id_);
}
inline ::CSProto::MsgID ErrorAck::id() const {
  // @@protoc_insertion_point(field_get:CSProto.ErrorAck.ID)
  return _internal_id();
}
inline void ErrorAck::_internal_set_id(::CSProto::MsgID value) {
  
  id_ = value;
}
inline void ErrorAck::set_id(::CSProto::MsgID value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:CSProto.ErrorAck.ID)
}

// .CSProto.ErrorCodeID Error = 2;
inline void ErrorAck::clear_error() {
  error_ = 0;
}
inline ::CSProto::ErrorCodeID ErrorAck::_internal_error() const {
  return static_cast< ::CSProto::ErrorCodeID >(error_);
}
inline ::CSProto::ErrorCodeID ErrorAck::error() const {
  // @@protoc_insertion_point(field_get:CSProto.ErrorAck.Error)
  return _internal_error();
}
inline void ErrorAck::_internal_set_error(::CSProto::ErrorCodeID value) {
  
  error_ = value;
}
inline void ErrorAck::set_error(::CSProto::ErrorCodeID value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:CSProto.ErrorAck.Error)
}

// -------------------------------------------------------------------

// LoginReq

// uint64 UserId = 1;
inline void LoginReq::clear_userid() {
  userid_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LoginReq::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LoginReq::userid() const {
  // @@protoc_insertion_point(field_get:CSProto.LoginReq.UserId)
  return _internal_userid();
}
inline void LoginReq::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  userid_ = value;
}
inline void LoginReq::set_userid(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:CSProto.LoginReq.UserId)
}

// string Username = 2;
inline void LoginReq::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& LoginReq::username() const {
  // @@protoc_insertion_point(field_get:CSProto.LoginReq.Username)
  return _internal_username();
}
inline void LoginReq::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:CSProto.LoginReq.Username)
}
inline std::string* LoginReq::mutable_username() {
  // @@protoc_insertion_point(field_mutable:CSProto.LoginReq.Username)
  return _internal_mutable_username();
}
inline const std::string& LoginReq::_internal_username() const {
  return username_.Get();
}
inline void LoginReq::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LoginReq::set_username(std::string&& value) {
  
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:CSProto.LoginReq.Username)
}
inline void LoginReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:CSProto.LoginReq.Username)
}
inline void LoginReq::set_username(const char* value,
    size_t size) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:CSProto.LoginReq.Username)
}
inline std::string* LoginReq::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LoginReq::release_username() {
  // @@protoc_insertion_point(field_release:CSProto.LoginReq.Username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LoginReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:CSProto.LoginReq.Username)
}

// -------------------------------------------------------------------

// LoginAck

// .CSProto.ErrorCodeID Err = 1;
inline void LoginAck::clear_err() {
  err_ = 0;
}
inline ::CSProto::ErrorCodeID LoginAck::_internal_err() const {
  return static_cast< ::CSProto::ErrorCodeID >(err_);
}
inline ::CSProto::ErrorCodeID LoginAck::err() const {
  // @@protoc_insertion_point(field_get:CSProto.LoginAck.Err)
  return _internal_err();
}
inline void LoginAck::_internal_set_err(::CSProto::ErrorCodeID value) {
  
  err_ = value;
}
inline void LoginAck::set_err(::CSProto::ErrorCodeID value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:CSProto.LoginAck.Err)
}

// -------------------------------------------------------------------

// EnterRoomReq

// -------------------------------------------------------------------

// EnterRoomAck

// .CSProto.ErrorCodeID Err = 1;
inline void EnterRoomAck::clear_err() {
  err_ = 0;
}
inline ::CSProto::ErrorCodeID EnterRoomAck::_internal_err() const {
  return static_cast< ::CSProto::ErrorCodeID >(err_);
}
inline ::CSProto::ErrorCodeID EnterRoomAck::err() const {
  // @@protoc_insertion_point(field_get:CSProto.EnterRoomAck.Err)
  return _internal_err();
}
inline void EnterRoomAck::_internal_set_err(::CSProto::ErrorCodeID value) {
  
  err_ = value;
}
inline void EnterRoomAck::set_err(::CSProto::ErrorCodeID value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:CSProto.EnterRoomAck.Err)
}

// -------------------------------------------------------------------

// EnterRoomNtf

// repeated .CSProto.EnterRoomRoleInfo RoleList = 1;
inline int EnterRoomNtf::_internal_rolelist_size() const {
  return rolelist_.size();
}
inline int EnterRoomNtf::rolelist_size() const {
  return _internal_rolelist_size();
}
inline ::CSProto::EnterRoomRoleInfo* EnterRoomNtf::mutable_rolelist(int index) {
  // @@protoc_insertion_point(field_mutable:CSProto.EnterRoomNtf.RoleList)
  return rolelist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSProto::EnterRoomRoleInfo >*
EnterRoomNtf::mutable_rolelist() {
  // @@protoc_insertion_point(field_mutable_list:CSProto.EnterRoomNtf.RoleList)
  return &rolelist_;
}
inline const ::CSProto::EnterRoomRoleInfo& EnterRoomNtf::_internal_rolelist(int index) const {
  return rolelist_.Get(index);
}
inline const ::CSProto::EnterRoomRoleInfo& EnterRoomNtf::rolelist(int index) const {
  // @@protoc_insertion_point(field_get:CSProto.EnterRoomNtf.RoleList)
  return _internal_rolelist(index);
}
inline ::CSProto::EnterRoomRoleInfo* EnterRoomNtf::_internal_add_rolelist() {
  return rolelist_.Add();
}
inline ::CSProto::EnterRoomRoleInfo* EnterRoomNtf::add_rolelist() {
  // @@protoc_insertion_point(field_add:CSProto.EnterRoomNtf.RoleList)
  return _internal_add_rolelist();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSProto::EnterRoomRoleInfo >&
EnterRoomNtf::rolelist() const {
  // @@protoc_insertion_point(field_list:CSProto.EnterRoomNtf.RoleList)
  return rolelist_;
}

// -------------------------------------------------------------------

// MoveReq

// .CSProto.MovementInfo Movement = 1;
inline bool MoveReq::_internal_has_movement() const {
  return this != internal_default_instance() && movement_ != nullptr;
}
inline bool MoveReq::has_movement() const {
  return _internal_has_movement();
}
inline const ::CSProto::MovementInfo& MoveReq::_internal_movement() const {
  const ::CSProto::MovementInfo* p = movement_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSProto::MovementInfo&>(
      ::CSProto::_MovementInfo_default_instance_);
}
inline const ::CSProto::MovementInfo& MoveReq::movement() const {
  // @@protoc_insertion_point(field_get:CSProto.MoveReq.Movement)
  return _internal_movement();
}
inline void MoveReq::unsafe_arena_set_allocated_movement(
    ::CSProto::MovementInfo* movement) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_);
  }
  movement_ = movement;
  if (movement) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSProto.MoveReq.Movement)
}
inline ::CSProto::MovementInfo* MoveReq::release_movement() {
  
  ::CSProto::MovementInfo* temp = movement_;
  movement_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::CSProto::MovementInfo* MoveReq::unsafe_arena_release_movement() {
  // @@protoc_insertion_point(field_release:CSProto.MoveReq.Movement)
  
  ::CSProto::MovementInfo* temp = movement_;
  movement_ = nullptr;
  return temp;
}
inline ::CSProto::MovementInfo* MoveReq::_internal_mutable_movement() {
  
  if (movement_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSProto::MovementInfo>(GetArena());
    movement_ = p;
  }
  return movement_;
}
inline ::CSProto::MovementInfo* MoveReq::mutable_movement() {
  // @@protoc_insertion_point(field_mutable:CSProto.MoveReq.Movement)
  return _internal_mutable_movement();
}
inline void MoveReq::set_allocated_movement(::CSProto::MovementInfo* movement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_);
  }
  if (movement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement)->GetArena();
    if (message_arena != submessage_arena) {
      movement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, movement, submessage_arena);
    }
    
  } else {
    
  }
  movement_ = movement;
  // @@protoc_insertion_point(field_set_allocated:CSProto.MoveReq.Movement)
}

// -------------------------------------------------------------------

// MoveAck

// .CSProto.MovementInfo Movement = 1;
inline bool MoveAck::_internal_has_movement() const {
  return this != internal_default_instance() && movement_ != nullptr;
}
inline bool MoveAck::has_movement() const {
  return _internal_has_movement();
}
inline const ::CSProto::MovementInfo& MoveAck::_internal_movement() const {
  const ::CSProto::MovementInfo* p = movement_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSProto::MovementInfo&>(
      ::CSProto::_MovementInfo_default_instance_);
}
inline const ::CSProto::MovementInfo& MoveAck::movement() const {
  // @@protoc_insertion_point(field_get:CSProto.MoveAck.Movement)
  return _internal_movement();
}
inline void MoveAck::unsafe_arena_set_allocated_movement(
    ::CSProto::MovementInfo* movement) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_);
  }
  movement_ = movement;
  if (movement) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSProto.MoveAck.Movement)
}
inline ::CSProto::MovementInfo* MoveAck::release_movement() {
  
  ::CSProto::MovementInfo* temp = movement_;
  movement_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::CSProto::MovementInfo* MoveAck::unsafe_arena_release_movement() {
  // @@protoc_insertion_point(field_release:CSProto.MoveAck.Movement)
  
  ::CSProto::MovementInfo* temp = movement_;
  movement_ = nullptr;
  return temp;
}
inline ::CSProto::MovementInfo* MoveAck::_internal_mutable_movement() {
  
  if (movement_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSProto::MovementInfo>(GetArena());
    movement_ = p;
  }
  return movement_;
}
inline ::CSProto::MovementInfo* MoveAck::mutable_movement() {
  // @@protoc_insertion_point(field_mutable:CSProto.MoveAck.Movement)
  return _internal_mutable_movement();
}
inline void MoveAck::set_allocated_movement(::CSProto::MovementInfo* movement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement_);
  }
  if (movement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(movement)->GetArena();
    if (message_arena != submessage_arena) {
      movement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, movement, submessage_arena);
    }
    
  } else {
    
  }
  movement_ = movement;
  // @@protoc_insertion_point(field_set_allocated:CSProto.MoveAck.Movement)
}

// -------------------------------------------------------------------

// MoveNtf

// .CSProto.MoveRoleInfo MoveRole = 1;
inline bool MoveNtf::_internal_has_moverole() const {
  return this != internal_default_instance() && moverole_ != nullptr;
}
inline bool MoveNtf::has_moverole() const {
  return _internal_has_moverole();
}
inline const ::CSProto::MoveRoleInfo& MoveNtf::_internal_moverole() const {
  const ::CSProto::MoveRoleInfo* p = moverole_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSProto::MoveRoleInfo&>(
      ::CSProto::_MoveRoleInfo_default_instance_);
}
inline const ::CSProto::MoveRoleInfo& MoveNtf::moverole() const {
  // @@protoc_insertion_point(field_get:CSProto.MoveNtf.MoveRole)
  return _internal_moverole();
}
inline void MoveNtf::unsafe_arena_set_allocated_moverole(
    ::CSProto::MoveRoleInfo* moverole) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(moverole_);
  }
  moverole_ = moverole;
  if (moverole) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSProto.MoveNtf.MoveRole)
}
inline ::CSProto::MoveRoleInfo* MoveNtf::release_moverole() {
  
  ::CSProto::MoveRoleInfo* temp = moverole_;
  moverole_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::CSProto::MoveRoleInfo* MoveNtf::unsafe_arena_release_moverole() {
  // @@protoc_insertion_point(field_release:CSProto.MoveNtf.MoveRole)
  
  ::CSProto::MoveRoleInfo* temp = moverole_;
  moverole_ = nullptr;
  return temp;
}
inline ::CSProto::MoveRoleInfo* MoveNtf::_internal_mutable_moverole() {
  
  if (moverole_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSProto::MoveRoleInfo>(GetArena());
    moverole_ = p;
  }
  return moverole_;
}
inline ::CSProto::MoveRoleInfo* MoveNtf::mutable_moverole() {
  // @@protoc_insertion_point(field_mutable:CSProto.MoveNtf.MoveRole)
  return _internal_mutable_moverole();
}
inline void MoveNtf::set_allocated_moverole(::CSProto::MoveRoleInfo* moverole) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(moverole_);
  }
  if (moverole) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(moverole)->GetArena();
    if (message_arena != submessage_arena) {
      moverole = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moverole, submessage_arena);
    }
    
  } else {
    
  }
  moverole_ = moverole;
  // @@protoc_insertion_point(field_set_allocated:CSProto.MoveNtf.MoveRole)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CSProto

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_CSMsg_2eproto
